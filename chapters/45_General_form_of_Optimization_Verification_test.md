## 45 General form of Optimization Verification test

몇몇 입력 데이터 x에 대하여, 입력 x에 대한 응답 y가 얼마나 좋은지를 보여주는 Score_X(y)값을 계산하는 방법을 알고 있을때, 최적화 검증 테스트를 적용할 수 있다. 더욱이, 근사치를 구하는 알고리즘을 사용해서 arg max_y Score_x(y)를 찾으려고 하지만, 검색 알고리즘은 때때로 최대값을 찾는데 실패한다는 것에 대하여 의심을 하게 될 수 있다. 앞선 음성인식 예제에서, x=A는 오디오 클립이고, y=S는 해당 오디오에 대한 문장이었다.

y*가 "올바른" 출력 이지만, 알고리즘은 대신에 y_out 이라는 값을 출력하였다고 가정 해 보자. 그러면, Score_x(y*) > Score_x(y_out) 인지를 측정하는 것이 가장 중요한 테스트가 된다. 만약 이 불균형이 지속된다면, 이것에 대해서는 최적화 알고리즘의 문제라고 볼 수 있다. 직전 챕터를 참조해 보면, 이러한 논리를 이해하는데 도움을 줄 것이다. 그렇지 않은 경우, Score_x(y)의 계산에 문제가 있다고 볼 수 있겠다.

한가지 더 예제를 살펴보자. 중국어-영어 기계 번역 시스템을 구축하고 있다는 가정이다. 이 시스템은 중국어 문장 C를 입력으로 받으면, 이에 대한 가능한 번역된 각각의 문장 E에 대하여 Score_C(E) 값을 계산한다. 예를 들어서, 주어진 문장이 C일때 번역이 E가 될 확률인 Score_C(E) = P(E|C) 계산 식을 사용할 수 있을 것이다.

알고리즘은 다음을 계산하여, 문장에 대한 번역을 시도할 수 있다:

<div style="text-align:center;">
  <img src="../img/45_1.PNG" style="text-align:center;"/>
</div>

하지만, 모든 가능성 있는 영어 문장 E의 집합이 너무 큰 경우에, 발견적 (heuristic)인 검색 알고리즘에 의존하게 될지도 모른다.

알고리즘이 올바른 번역 E* 대신에, 올바르지 못한 번역인 E_out을 출력하였다고 가정 해 보자. 그러면, 최적화 검증 테스트는 Score_C(E*) > Score_C(E_out) 인지 아닌지에 대한 계산을 수행할 것을 요구할지도 모른다. 만약 이 불균형이 지속된다면, Score_C() 함수는 E*를 출력 E_out보다 우수하다고 올바르게 인식 하였다고 볼 수 있다. 이렇게, 이러한 에러가 발생한 이유를 검색 알고리즘의 탓으로 돌릴게 될 수 있다. 그렇지 않다면, 이 에러의 발생 이유는 Score_C()의 계산 탓이 된다.

AI에서, 스코어 함수 Score_x() 가장 먼저 학습하고, 그리고나서 최적화 알고리즘을 사용하는 것은 아주 일반적인 "디자인 패턴" 이다. 만약, 이러한 패턴을 눈치채는 것이 가능하다면, 최적화 검증 테스트를 사용할 수 있고, 이를 통해서 에러의 원인을 이해하게 될 수 있다.
